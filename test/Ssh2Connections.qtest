#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%require-types
%strict-args
%enable-all-warnings

%requires ../qlib/Ssh2Connections.qm
%requires ssh2 >= 1.2

%requires Util
%requires QUnit

%exec-class Ssh2ConnectionsTest

class Ssh2ConnectionsTest inherits QUnit::Test {
    public {
    }

    private:internal {
        string uri;

        timeout timeout = 10s;

        const MyOpts = Opts + {
            "privkey": "k,private-key=s",
            "timeout": "T,timeout=i",
        };

        const ColumnOffset = 25;
    }

    constructor() : Test("Ssh2ConnectionsTest", "1.0", \ARGV, MyOpts) {
        if (m_options.timeout)
            timeout = m_options.timeout * 1000;
        uri = shift ARGV ?? sprintf("%s@localhost", getusername());

        addTestCase("SftpConnection test", \sftpTest());
        addTestCase("Ssh2Connection test", \ssh2Test());

        set_return_value(main());
    }

    *hash getOptions() {
        hash opts;
        if (m_options.privkey) {
            opts.keyfile = m_options.privkey;
        }
        else {
            if (PlatformOS == "Windows")
                exit(0);

            string sshdir = ENV.HOME + "/.ssh";
            if (is_file(sshdir + "/id_rsa"))
                opts.keyfile = sshdir + "/id_rsa";
            else if (is_file(sshdir + "/id_dsa"))
                opts.keyfile = sshdir + "/id_dsa";
        }
        return opts;
    }

    sftpTest() {
        SftpConnection conn("test", "test", uri, False, getOptions(), parse_url(uri));

        SFTPClient sc = conn.get();

        string file = get_random_string();
        string fn = "/tmp/" + file;

        sc.connect();
        hash info = sc.info();

        if (m_options.verbose)
            stdout.printf("SFTP %s@%s:%d auth: %y, hostkey: %y, crypt_cs: %y, tmp: %s\n", info.ssh2user, info.ssh2host, info.ssh2port, info.authenticated, info.methods.HOSTKEY, info.methods.CRYPT_CS, fn);

        testAssertionValue("SftpClient::info()", info.connected, True);
        testAssertionValue("SftpClient::list()", sc.list(NOTHING, timeout).type(), Type::Hash);
        testAssertionValue("SftpClient::listFull()", sc.listFull(NOTHING, timeout).type(), Type::List);

        hash<ConnectionConstructorInfo> conn_info = conn.getConstructorInfo();
        assertEq("ssh2", conn_info.module);
        assertEq("Qore::SSH2::SFTPClient", conn_info.class_name);
        assertEq(uri, conn_info.args[0]);
        checkPreAndPostProcessing(conn_info);
    }

    ssh2Test() {
        Ssh2ClientConnection conn("test", "test", uri, False, getOptions(), parse_url(uri));

        SSH2Client sc = conn.get();
        SSH2Channel chan = sc.openSessionChannel();
        chan.exec("ls -l | head -5");
        any str = chan.read();
        assertEq(Type::String, str.type());

        hash<ConnectionConstructorInfo> conn_info = conn.getConstructorInfo();
        assertEq("ssh2", conn_info.module);
        assertEq("Qore::SSH2::SSH2Client", conn_info.class_name);
        assertEq(uri, conn_info.args[0]);
        checkPreAndPostProcessing(conn_info);
    }

    private checkPreAndPostProcessing(hash<ConnectionConstructorInfo> info) {
        Program p(PO_NEW_STYLE | PO_STRICT_ARGS | PO_REQUIRE_TYPES);
        if (info.module)
            p.loadModule(info.module);
        if (info.pre_processing) {
            string pre_processing = sprintf("sub pre_processing(reference<*softlist<auto>> args, bool connect, *hash rtopts) { %s }", info.pre_processing);
            # ensure that the pre processing code can be parsed
            p.parse(pre_processing, "pre processing");
            assertTrue(True, "pre processing: " + info.class_name);
        }
        if (info.post_processing) {
            string post_processing = sprintf("sub post_processing(%s obj, bool connect, *hash rtopts) { %s }", info.class_name, info.post_processing);
            # ensure that the post processing code can be parsed
            p.parse(post_processing, "post processing");
            assertTrue(True, "post processing: " + info.class_name);
        }
    }

    private usageIntern() {
        TestReporter::usageIntern(ColumnOffset);
        printOption("-k,--private-key=ARG", "set private key to use for authentication", ColumnOffset);
        printOption("-T,--timeout=ARG", sprintf("set timeout in seconds (def: %ds)", timeout / 1000), ColumnOffset);
    }
}
